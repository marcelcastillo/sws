diff --git a/.gitignore b/.gitignore
index 9fda8de..d092061 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,9 @@ sws
 sws-directories/
 test.sh
 script.sh
+file
+make-swsdirs
+out.txt
+test-sws.sh
+docroot/
+index.html
diff --git a/http.c b/http.c
index 746864b..6534937 100644
--- a/http.c
+++ b/http.c
@@ -3,8 +3,10 @@
 #include <sys/stat.h>
 
 #include <ctype.h>
+#include <dirent.h>
 #include <fcntl.h>
 #include <limits.h>
+#include <pwd.h>
 #include <regex.h>
 #include <stdlib.h>
 #include <string.h>
@@ -14,6 +16,28 @@
 #include "cgi.h"
 #include "server.h"
 
+static time_t
+parse_http_date(const char *s)
+{
+	struct tm tm;
+	char *end;
+
+	if (s == NULL || *s == '\0') {
+		return (time_t)-1;
+	}
+
+	memset(&tm, 0, sizeof(tm));
+
+	/* RFC 1123 / HTTP-date format: "Wed, 21 Oct 2015 07:28:00 GMT" */
+	end = strptime(s, "%a, %d %b %Y %H:%M:%S GMT", &tm);
+	if (end == NULL) {
+		return (time_t)-1;
+	}
+
+	/* Interpret as GMT */
+	return timegm(&tm);
+}
+
 int
 validate_method(const char *method)
 {
@@ -347,8 +371,8 @@ parse_http_request(FILE *stream, struct http_request *request)
 int
 craft_http_response(FILE *stream, enum HTTP_STATUS_CODE status_code,
                     const char *status_text, const char *body,
-                    const char *content_type, int is_head,
-                    struct http_response *resp)
+                    const char *content_type, const char *last_modified,
+                    int is_head, struct http_response *resp)
 {
 	time_t now = time(NULL);
 	struct tm gmt;
@@ -360,6 +384,9 @@ craft_http_response(FILE *stream, enum HTTP_STATUS_CODE status_code,
 	fprintf(stream, "HTTP/1.0 %d %s\r\n", status_code, status_text);
 	fprintf(stream, "Date: %s\r\n", date_buf);
 	fprintf(stream, "Server: sws/1.0\r\n");
+	if (last_modified) {
+		fprintf(stream, "Last-Modified: %s\r\n", last_modified);
+	}
 	fprintf(stream, "Content-Length: %zu\r\n", len);
 	fprintf(stream, "Content-Type: %s\r\n",
 	        content_type ? content_type : "text/plain");
@@ -368,7 +395,6 @@ craft_http_response(FILE *stream, enum HTTP_STATUS_CODE status_code,
 		fprintf(stream, "%s", body);
 	}
 
-	/* Add to the resp struct */
 	if (resp) {
 		resp->status_code = status_code;
 		resp->content_len = len;
@@ -404,6 +430,19 @@ guess_content_type(const char *path)
 	return "application/octet-stream";
 }
 
+struct dir_entry {
+	char *name;
+	int is_dir;
+};
+
+static int
+dir_entry_cmp(const void *a, const void *b)
+{
+	const struct dir_entry *ea = a;
+	const struct dir_entry *eb = b;
+	return strcmp(ea->name, eb->name);
+}
+
 static int
 serve_static_file(FILE *stream, const struct http_request *req,
                   const struct server_config *cfg, int is_head,
@@ -416,63 +455,265 @@ serve_static_file(FILE *stream, const struct http_request *req,
 	ssize_t nread;
 	size_t total = 0;
 
-	if (cfg->docroot == NULL) {
+	const char *uri = req->path;
+	const char *base = NULL;    /* docroot / user-sws */
+	const char *subpath = NULL; /* part after docroot */
+
+	char user_root[PATH_MAX];
+
+	/* ----- Decide base directory (docroot vs /~user) ----- */
+
+	if (strncmp(uri, "/~", 2) == 0) {
+		/* /~user[/... ] → /home/user/sws[/...] */
+		const char *user_start = uri + 2;
+		const char *slash = strchr(user_start, '/');
+		char username[64];
+
+		if (slash) {
+			size_t ulen = (size_t)(slash - user_start);
+			if (ulen == 0 || ulen >= sizeof(username)) {
+				const char *body = "404 Not Found\n";
+				craft_http_response(stream, HTTP_STATUS_NOT_FOUND, "Not Found",
+				                    body, "text/plain", NULL, is_head, resp);
+				return -1;
+			}
+			memcpy(username, user_start, ulen);
+			username[ulen] = '\0';
+			subpath = slash; /* includes leading '/' */
+		} else {
+			/* "/~user" with no trailing slash → treat as "/~user/" */
+			size_t ulen = strlen(user_start);
+			if (ulen == 0 || ulen >= sizeof(username)) {
+				const char *body = "404 Not Found\n";
+				craft_http_response(stream, HTTP_STATUS_NOT_FOUND, "Not Found",
+				                    body, "text/plain", NULL, is_head, resp);
+				return -1;
+			}
+			memcpy(username, user_start, ulen + 1);
+			subpath = "/"; /* inside ~/sws */
+		}
+
+		struct passwd *pw = getpwnam(username);
+		if (!pw) {
+			const char *body = "404 Not Found\n";
+			craft_http_response(stream, HTTP_STATUS_NOT_FOUND, "Not Found",
+			                    body, "text/plain", NULL, is_head, resp);
+			return -1;
+		}
+
+		if (snprintf(user_root, sizeof(user_root), "%s/sws", pw->pw_dir) >=
+		    (int)sizeof(user_root)) {
+			const char *body = "500 Internal Server Error\n";
+			craft_http_response(stream, HTTP_STATUS_INTERNAL_SERVER_ERROR,
+			                    "Internal Server Error", body, "text/plain",
+			                    NULL, is_head, resp);
+			return -1;
+		}
+		base = user_root;
+	} else {
+		base = cfg->docroot;
+		subpath = uri;
+	}
+
+	if (base == NULL) {
 		const char *body = "500 Internal Server Error\n";
 		craft_http_response(stream, HTTP_STATUS_INTERNAL_SERVER_ERROR,
-		                    "Internal Server Error", body, "text/plain", 0,
-		                    resp);
+		                    "Internal Server Error", body, "text/plain", NULL,
+		                    is_head, resp);
 		return -1;
 	}
 
-	/* Build full path: docroot + path */
-	if (snprintf(fullpath, sizeof(fullpath), "%s%s", cfg->docroot, req->path) >=
+	/* Build full path: base + subpath */
+	if (snprintf(fullpath, sizeof(fullpath), "%s%s", base, subpath) >=
 	    (int)sizeof(fullpath)) {
 		const char *body = "414 Request-URI Too Long\n";
 		craft_http_response(stream, HTTP_STATUS_BAD_REQUEST, "Bad Request",
-		                    body, "text/plain", 0, resp);
+		                    body, "text/plain", NULL, is_head, resp);
 		return -1;
 	}
 
 	if (stat(fullpath, &st) == -1) {
 		const char *body = "404 Not Found\n";
 		craft_http_response(stream, HTTP_STATUS_NOT_FOUND, "Not Found", body,
-		                    "text/plain", 0, resp);
+		                    "text/plain", NULL, is_head, resp);
 		return -1;
 	}
 
-	/* If it's a directory, try index.html for now */
+	time_t ims = (time_t)-1;
+	if (req->if_modified_since[0] != '\0') {
+		ims = parse_http_date(req->if_modified_since);
+	}
+
+	/* ----- Directory handling (index.html or auto index) ----- */
+
 	if (S_ISDIR(st.st_mode)) {
 		char indexpath[PATH_MAX];
+		struct stat st_index;
 
-		if (snprintf(indexpath, sizeof(indexpath), "%s%s%s", cfg->docroot,
-		             req->path,
-		             (req->path[strlen(req->path) - 1] == '/') ? "" : "/") >=
+		if (snprintf(indexpath, sizeof(indexpath), "%s%s%s", base, subpath,
+		             (subpath[strlen(subpath) - 1] == '/') ? "" : "/") >=
 		    (int)sizeof(indexpath)) {
 			const char *body = "400 Bad Request\n";
 			craft_http_response(stream, HTTP_STATUS_BAD_REQUEST, "Bad Request",
-			                    body, "text/plain", 0, resp);
+			                    body, "text/plain", NULL, is_head, resp);
 			return -1;
 		}
 
 		strncat(indexpath, "index.html",
 		        sizeof(indexpath) - strlen(indexpath) - 1);
 
-		if (stat(indexpath, &st) == -1 || !S_ISREG(st.st_mode)) {
-			const char *body = "403 Forbidden\n";
-			craft_http_response(stream, HTTP_STATUS_FORBIDDEN, "Forbidden",
-			                    body, "text/plain", 0, resp);
-			return -1;
+		/* If index.html exists and is a regular file, serve that */
+		if (stat(indexpath, &st_index) == 0 && S_ISREG(st_index.st_mode)) {
+			strncpy(fullpath, indexpath, sizeof(fullpath));
+			fullpath[sizeof(fullpath) - 1] = '\0';
+			st = st_index; /* use index's st for Last-Modified */
+		} else {
+			/* No index.html: 304 based on directory mtime */
+			if (ims != (time_t)-1 && st.st_mtime <= ims) {
+				craft_http_response(stream, HTTP_STATUS_NOT_MODIFIED,
+				                    "Not Modified", NULL, NULL, NULL, is_head,
+				                    resp);
+				return 0;
+			}
+
+			/* No index.html: generate a directory index */
+			DIR *dir = opendir(fullpath);
+			if (!dir) {
+				const char *body = "403 Forbidden\n";
+				craft_http_response(stream, HTTP_STATUS_FORBIDDEN, "Forbidden",
+				                    body, "text/plain", NULL, is_head, resp);
+				return -1;
+			}
+
+			struct dir_entry *entries = NULL;
+			size_t nent = 0, cap = 0;
+			struct dirent *de;
+
+			while ((de = readdir(dir)) != NULL) {
+				const char *name = de->d_name;
+				if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) {
+					continue;
+				}
+				if (name[0] == '.') { /* hidden files ignored */
+					continue;
+				}
+
+				if (nent == cap) {
+					size_t newcap = cap ? cap * 2 : 16;
+					struct dir_entry *tmp =
+						realloc(entries, newcap * sizeof(*entries));
+					if (!tmp) {
+						closedir(dir);
+						free(entries);
+						const char *body = "500 Internal Server Error\n";
+						craft_http_response(stream,
+						                    HTTP_STATUS_INTERNAL_SERVER_ERROR,
+						                    "Internal Server Error", body,
+						                    "text/plain", NULL, is_head, resp);
+						return -1;
+					}
+					entries = tmp;
+					cap = newcap;
+				}
+
+				entries[nent].name = strdup(name);
+				if (!entries[nent].name) {
+					closedir(dir);
+					for (size_t i = 0; i < nent; i++) {
+						free(entries[i].name);
+					}
+					free(entries);
+					const char *body = "500 Internal Server Error\n";
+					craft_http_response(stream,
+					                    HTTP_STATUS_INTERNAL_SERVER_ERROR,
+					                    "Internal Server Error", body,
+					                    "text/plain", NULL, is_head, resp);
+					return -1;
+				}
+
+				/* Determine if this entry is a directory */
+				char pathbuf[PATH_MAX];
+				entries[nent].is_dir = 0;
+				if (snprintf(pathbuf, sizeof(pathbuf), "%s/%s", fullpath,
+				             name) < (int)sizeof(pathbuf) &&
+				    stat(pathbuf, &st_index) == 0 &&
+				    S_ISDIR(st_index.st_mode)) {
+					entries[nent].is_dir = 1;
+				}
+
+				nent++;
+			}
+			closedir(dir);
+
+			qsort(entries, nent, sizeof(*entries), dir_entry_cmp);
+
+			/* Build HTML body */
+			size_t body_cap = 8192;
+			char *body = malloc(body_cap);
+			if (!body) {
+				for (size_t i = 0; i < nent; i++) {
+					free(entries[i].name);
+				}
+				free(entries);
+				const char *msg = "500 Internal Server Error\n";
+				craft_http_response(stream, HTTP_STATUS_INTERNAL_SERVER_ERROR,
+				                    "Internal Server Error", msg, "text/plain",
+				                    NULL, is_head, resp);
+				return -1;
+			}
+			body[0] = '\0';
+
+			snprintf(body, body_cap,
+			         "<html><head><title>Index of %s</title></head><body>\n"
+			         "<h1>Index of %s</h1>\n<ul>\n",
+			         req->path, req->path);
+
+			for (size_t i = 0; i < nent; i++) {
+				char line[PATH_MAX + 64];
+				const char *slash = entries[i].is_dir ? "/" : "";
+				snprintf(line, sizeof(line),
+				         "<li><a href=\"%s%s\">%s%s</a></li>\n",
+				         entries[i].name, slash, entries[i].name, slash);
+				if (strlen(body) + strlen(line) + 1 < body_cap) {
+					strcat(body, line);
+				}
+			}
+
+			strncat(body, "</ul>\n</body></html>\n",
+			        body_cap - strlen(body) - 1);
+
+			/* Last-Modified from directory's mtime */
+			char lastmod[64];
+			struct tm gmt;
+			gmtime_r(&st.st_mtime, &gmt);
+			strftime(lastmod, sizeof(lastmod), "%a, %d %b %Y %H:%M:%S GMT",
+			         &gmt);
+
+			craft_http_response(stream, HTTP_STATUS_OK, "OK", body, "text/html",
+			                    lastmod, is_head, resp);
+
+			for (size_t i = 0; i < nent; i++) {
+				free(entries[i].name);
+			}
+			free(entries);
+			free(body);
+			return 0;
 		}
+	}
+
+	/* ----- Regular file serving ----- */
 
-		/* Use index.html instead */
-		strncpy(fullpath, indexpath, sizeof(fullpath));
-		fullpath[sizeof(fullpath) - 1] = '\0';
+	/* For regular files, possibly return 304 instead of body */
+	if (ims != (time_t)-1 && st.st_mtime <= ims) {
+		craft_http_response(stream, HTTP_STATUS_NOT_MODIFIED, "Not Modified",
+		                    NULL, NULL, NULL, is_head, resp);
+		return 0;
 	}
 
 	if (!S_ISREG(st.st_mode)) {
 		const char *body = "403 Forbidden\n";
 		craft_http_response(stream, HTTP_STATUS_FORBIDDEN, "Forbidden", body,
-		                    "text/plain", 0, resp);
+		                    "text/plain", NULL, is_head, resp);
 		return -1;
 	}
 
@@ -480,34 +721,37 @@ serve_static_file(FILE *stream, const struct http_request *req,
 	if (fd == -1) {
 		const char *body = "403 Forbidden\n";
 		craft_http_response(stream, HTTP_STATUS_FORBIDDEN, "Forbidden", body,
-		                    "text/plain", 0, resp);
+		                    "text/plain", NULL, is_head, resp);
 		return -1;
 	}
 
-	/* Very simple: read whole file into memory */
 	buf = malloc(st.st_size + 1);
 	if (!buf) {
 		close(fd);
 		const char *body = "500 Internal Server Error\n";
 		craft_http_response(stream, HTTP_STATUS_INTERNAL_SERVER_ERROR,
-		                    "Internal Server Error", body, "text/plain", 0,
-		                    resp);
+		                    "Internal Server Error", body, "text/plain", NULL,
+		                    is_head, resp);
 		return -1;
 	}
 
 	while ((nread = read(fd, buf + total, st.st_size - total)) > 0) {
 		total += (size_t)nread;
 	}
-
 	close(fd);
 	buf[total] = '\0';
 
 	const char *ctype = guess_content_type(fullpath);
-	/* Note: craft_http_response uses strlen(body) for Content-Length,
-	   so this only works correctly for text files; that's fine for a first
-	   pass. */
-	craft_http_response(stream, HTTP_STATUS_OK, "OK", buf, ctype, is_head,
-	                    resp);
+
+	/* Last-Modified for this file */
+	char lastmod[64];
+	struct tm gmt;
+	gmtime_r(&st.st_mtime, &gmt);
+	strftime(lastmod, sizeof(lastmod), "%a, %d %b %Y %H:%M:%S GMT", &gmt);
+
+	craft_http_response(stream, HTTP_STATUS_OK, "OK", buf, ctype, lastmod,
+	                    is_head, resp);
+
 	free(buf);
 	return 0;
 }
@@ -552,7 +796,8 @@ handle_http_connection(FILE *stream, const struct server_config *cfg,
 			break;
 		}
 
-		craft_http_response(stream, status, text, body, "text/plain", 0, resp);
+		craft_http_response(stream, status, text, body, "text/plain", NULL, 0,
+		                    resp);
 		return -1;
 	}
 
@@ -563,7 +808,7 @@ handle_http_connection(FILE *stream, const struct server_config *cfg,
 	if (normalize_path(req->path, norm, sizeof(norm)) < 0) {
 		const char *body = "400 Bad Request\n";
 		craft_http_response(stream, HTTP_STATUS_BAD_REQUEST, "Bad Request",
-		                    body, "text/plain", is_head, resp);
+		                    body, "text/plain", NULL, is_head, resp);
 		return -1;
 	}
 
@@ -578,7 +823,7 @@ handle_http_connection(FILE *stream, const struct server_config *cfg,
 			const char *body = "500 Internal Server Error\n";
 			craft_http_response(stream, HTTP_STATUS_INTERNAL_SERVER_ERROR,
 			                    "Internal Server Error", body, "text/plain",
-			                    is_head, resp);
+			                    NULL, is_head, resp);
 			return -1;
 		}
 		return 0;
diff --git a/http.h b/http.h
index bcd77a7..5743a2f 100644
--- a/http.h
+++ b/http.h
@@ -12,12 +12,12 @@ struct http_request {
 	char path[MAX_URI];
 	char version[MAX_VERSION];
 	char if_modified_since[MAX_HEADER_VALUE];
-    char request_line[MAX_URI + MAX_METHOD + MAX_VERSION + 4];
+	char request_line[MAX_URI + MAX_METHOD + MAX_VERSION + 4];
 };
 
 struct http_response {
-    int status_code;
-    size_t content_len;
+	int status_code;
+	size_t content_len;
 };
 
 struct server_config;
@@ -107,8 +107,8 @@ enum HTTP_PARSE_RESULT parse_http_request(FILE *stream,
  */
 int craft_http_response(FILE *stream, enum HTTP_STATUS_CODE status_code,
                         const char *status_text, const char *body,
-                        const char *content_type, int is_head,
-                        struct http_response *resp);
+                        const char *content_type, const char *last_modified,
+                        int is_head, struct http_response *resp);
 
 /*
  * Handles a single HTTP connection on the given stream.
diff --git a/server.h b/server.h
index 735c971..01b4e4b 100644
--- a/server.h
+++ b/server.h
@@ -16,7 +16,7 @@ struct server_config {
 	int have_bind_address;
 
 	char *logfile;
-    FILE *logfp;
+	FILE *logfp;
 
 	int port;
 
